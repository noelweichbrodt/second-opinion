import * as fs from "fs";
import * as path from "path";

export interface ReviewMetadata {
  sessionName: string;
  provider: string;
  model: string;
  timestamp: string;
  filesReviewed: string[];
  tokensUsed?: number;
  task?: string;
}

/**
 * Generate a slug from a session name
 */
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .substring(0, 50);
}

/**
 * Validate that reviewsDir is safe (relative, no traversal)
 */
function validateReviewsDir(reviewsDir: string): void {
  // Must be relative
  if (path.isAbsolute(reviewsDir)) {
    throw new Error(`reviewsDir must be relative, got: ${reviewsDir}`);
  }

  // Must not contain path traversal
  if (reviewsDir.includes("..")) {
    throw new Error(`reviewsDir contains path traversal: ${reviewsDir}`);
  }

  // Normalize and verify no traversal after normalization
  const normalized = path.normalize(reviewsDir);
  if (normalized.startsWith("..")) {
    throw new Error(`reviewsDir resolves outside project: ${reviewsDir}`);
  }
}

/**
 * Derive a short task slug from a task description
 */
function deriveTaskSlug(task: string): string {
  // Take first few meaningful words
  const words = task
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .filter((w) => w.length > 2)
    .slice(0, 4);

  if (words.length === 0) {
    return "task";
  }

  return words.join("-").substring(0, 30);
}

/**
 * Write a review/response to a markdown file
 */
export function writeReview(
  projectPath: string,
  reviewsDir: string,
  metadata: ReviewMetadata,
  review: string
): string {
  // Validate reviewsDir before using it
  validateReviewsDir(reviewsDir);

  // Ensure output directory exists
  const outputDirPath = path.join(projectPath, reviewsDir);
  if (!fs.existsSync(outputDirPath)) {
    fs.mkdirSync(outputDirPath, { recursive: true });
  }

  // Generate filename based on whether this is a task or review
  const sessionSlug = slugify(metadata.sessionName);
  let filename: string;
  if (metadata.task) {
    const taskSlug = deriveTaskSlug(metadata.task);
    filename = `${sessionSlug}.${metadata.provider}.${taskSlug}.md`;
  } else {
    filename = `${sessionSlug}.${metadata.provider}.review.md`;
  }
  const filePath = path.join(outputDirPath, filename);

  // Build the document
  const lines: string[] = [];

  // Header based on task or review
  if (metadata.task) {
    lines.push(`# Second Opinion - ${metadata.sessionName}`);
    lines.push("");
    lines.push(`**Task:** ${metadata.task.substring(0, 200)}${metadata.task.length > 200 ? "..." : ""}`);
  } else {
    lines.push(`# Code Review - ${metadata.sessionName}`);
  }
  lines.push("");
  lines.push(`**Provider:** ${metadata.provider} (${metadata.model})`);
  lines.push(`**Date:** ${metadata.timestamp}`);
  if (metadata.tokensUsed) {
    lines.push(`**Tokens Used:** ${metadata.tokensUsed.toLocaleString()}`);
  }
  lines.push("");

  if (metadata.filesReviewed.length > 0) {
    lines.push("## Files Analyzed");
    lines.push("");
    for (const file of metadata.filesReviewed) {
      const relativePath = path.relative(projectPath, file);
      lines.push(`- ${relativePath}`);
    }
    lines.push("");
  }

  lines.push("---");
  lines.push("");
  lines.push(review);
  lines.push("");
  lines.push("---");
  lines.push("*Generated by second-opinion MCP server*");

  // Write the file
  fs.writeFileSync(filePath, lines.join("\n"));

  return filePath;
}

/**
 * Derive a session name from the conversation context
 */
export function deriveSessionName(
  conversationContext: string,
  fallback: string = "review"
): string {
  // Try to extract from the first user message
  const userMatch = conversationContext.match(/\*\*User\*\*:\n(.+?)(?:\n|$)/);
  if (userMatch) {
    const firstMessage = userMatch[1].trim();
    // Take first 50 chars, clean up
    const name = firstMessage
      .substring(0, 50)
      .replace(/[^a-zA-Z0-9\s-]/g, "")
      .trim();
    if (name.length > 3) {
      return name;
    }
  }

  return fallback;
}
