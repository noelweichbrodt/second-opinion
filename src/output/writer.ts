import * as fs from "fs";
import * as path from "path";

export interface ReviewMetadata {
  sessionName: string;
  provider: string;
  model: string;
  timestamp: string;
  filesReviewed: string[];
  tokensUsed?: number;
  task?: string;
}

export interface EgressSummary {
  projectFilesSent: number;
  projectFilePaths: string[];
  externalFilesSent: number;
  externalFilePaths: string[];
  externalLocations: string[];
  blockedFiles: {
    path: string;
    reason: string;
  }[];
  provider: string;
  /** Statistics about secrets that were redacted from file content */
  redactions?: {
    totalCount: number;
    types: string[];
  };
  /** PR context metadata when reviewing a pull request */
  prContext?: {
    prNumber: number;
    prUrl: string;
    commentsIncluded: number;
    reviewsIncluded: number;
  };
}

/**
 * Generate a slug from a session name
 */
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .substring(0, 50);
}

/**
 * Validate that reviewsDir is safe (relative, no traversal)
 */
function validateReviewsDir(reviewsDir: string): void {
  // Must be relative
  if (path.isAbsolute(reviewsDir)) {
    throw new Error(`reviewsDir must be relative, got: ${reviewsDir}`);
  }

  // Must not contain path traversal
  if (reviewsDir.includes("..")) {
    throw new Error(`reviewsDir contains path traversal: ${reviewsDir}`);
  }

  // Normalize and verify no traversal after normalization
  const normalized = path.normalize(reviewsDir);
  if (normalized.startsWith("..")) {
    throw new Error(`reviewsDir resolves outside project: ${reviewsDir}`);
  }
}

/**
 * Derive a short task slug from a task description
 */
function deriveTaskSlug(task: string): string {
  // Take first few meaningful words
  const words = task
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .filter((w) => w.length > 2)
    .slice(0, 4);

  if (words.length === 0) {
    return "task";
  }

  return words.join("-").substring(0, 30);
}

/**
 * Generate base filename (without extension) for output files
 */
function generateBaseFilename(metadata: ReviewMetadata): string {
  const sessionSlug = slugify(metadata.sessionName);
  if (metadata.task) {
    const taskSlug = deriveTaskSlug(metadata.task);
    return `${sessionSlug}.${metadata.provider}.${taskSlug}`;
  }
  return `${sessionSlug}.${metadata.provider}.review`;
}

/**
 * Ensure output directory exists and return its path
 */
function ensureOutputDir(projectPath: string, reviewsDir: string): string {
  validateReviewsDir(reviewsDir);
  const outputDirPath = path.join(projectPath, reviewsDir);
  if (!fs.existsSync(outputDirPath)) {
    fs.mkdirSync(outputDirPath, { recursive: true });
  }
  return outputDirPath;
}

/**
 * Write a review/response to a markdown file
 */
export function writeReview(
  projectPath: string,
  reviewsDir: string,
  metadata: ReviewMetadata,
  review: string
): string {
  const outputDirPath = ensureOutputDir(projectPath, reviewsDir);
  const filePath = path.join(outputDirPath, `${generateBaseFilename(metadata)}.md`);

  // Build the document
  const lines: string[] = [];

  // Header based on task or review
  if (metadata.task) {
    lines.push(`# Second Opinion - ${metadata.sessionName}`);
    lines.push("");
    lines.push(`**Task:** ${metadata.task.substring(0, 200)}${metadata.task.length > 200 ? "..." : ""}`);
  } else {
    lines.push(`# Code Review - ${metadata.sessionName}`);
  }
  lines.push("");
  lines.push(`**Provider:** ${metadata.provider} (${metadata.model})`);
  lines.push(`**Date:** ${metadata.timestamp}`);
  if (metadata.tokensUsed) {
    lines.push(`**Tokens Used:** ${metadata.tokensUsed.toLocaleString()}`);
  }
  lines.push("");

  if (metadata.filesReviewed.length > 0) {
    lines.push("## Files Analyzed");
    lines.push("");
    for (const file of metadata.filesReviewed) {
      const relativePath = path.relative(projectPath, file);
      lines.push(`- ${relativePath}`);
    }
    lines.push("");
  }

  lines.push("---");
  lines.push("");
  lines.push(review);
  lines.push("");
  lines.push("---");
  lines.push("*Generated by second-opinion MCP server*");

  // Write the file
  fs.writeFileSync(filePath, lines.join("\n"));

  return filePath;
}

/**
 * Derive a session name from the conversation context
 */
export function deriveSessionName(
  conversationContext: string,
  fallback: string = "review"
): string {
  // Try to extract from the first user message
  const userMatch = conversationContext.match(/\*\*User\*\*:\n(.+?)(?:\n|$)/);
  if (userMatch) {
    const firstMessage = userMatch[1].trim();
    // Take first 50 chars, clean up
    const name = firstMessage
      .substring(0, 50)
      .replace(/[^a-zA-Z0-9\s-]/g, "")
      .trim();
    if (name.length > 3) {
      return name;
    }
  }

  return fallback;
}

/**
 * Write an egress manifest JSON file for audit trail
 * This records exactly what files were sent to the external LLM
 */
export function writeEgressManifest(
  projectPath: string,
  reviewsDir: string,
  metadata: ReviewMetadata,
  egressData: EgressSummary
): string {
  const outputDirPath = ensureOutputDir(projectPath, reviewsDir);
  const filePath = path.join(outputDirPath, `${generateBaseFilename(metadata)}.egress.json`);

  // Build the manifest
  const manifest = {
    timestamp: metadata.timestamp,
    provider: egressData.provider,
    model: metadata.model,
    sessionName: metadata.sessionName,
    task: metadata.task || null,
    egress: {
      projectFiles: {
        count: egressData.projectFilesSent,
        paths: egressData.projectFilePaths.map((p) =>
          path.relative(projectPath, p)
        ),
      },
      externalFiles: {
        count: egressData.externalFilesSent,
        paths: egressData.externalFilePaths,
        locations: egressData.externalLocations,
      },
      blockedFiles: egressData.blockedFiles,
      totalFilesSent:
        egressData.projectFilesSent + egressData.externalFilesSent,
    },
  };

  // Write the file
  fs.writeFileSync(filePath, JSON.stringify(manifest, null, 2));

  return filePath;
}
